package Lesson4;

public class PrintOutManager {
    int turn;
    int maxTurn;

    public PrintOutManager(int startTurn, int maxTurn) {
        turn = startTurn;
        this.maxTurn = maxTurn + 1;
    }

    public synchronized void printLetter(char letter, int when) {
        try {
            while (when != turn) {
                //если указать wait() c таймаутом, тогда программа будет
                //корректно работать и без notify() / notifyAll()
                wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.print(letter);
        try {
            Thread.sleep(300);  // для наглядности. Через 300 мсек - передаем
                                     // управление следующему потоку
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // Передаем очередь следующему потоку. Здесь существует скрытая опасность
        // передать очередь уже завершившемуся потоку и тогда программа "зависнет".
        // Но в нашей задаче все происходит равномерно и каждый поток отрабатывает
        // вывод в консоль ровно 5 раз, и завершаются они также синхронно.
        // Поэтому данный механизм корректно работает.
        nextTurn();

        // Если wait() выше указать с таймаутом (например wait(100)) тогда использование
        // notify() / notifyAll() станет необязательным. Программа корректно отрабатывает.
        // При использовании wait() без таймаута использование notifyAll() становится
        // необходимым, так как при обычном notify() уведомление может уйти не тому потоку
        // и программа зависнет.
        // Таким образом:
        //   1) в случае нескольких потоков, когда управление необходимо передать
        //      какому-то конкретному (в нашем случае - следующему по очереди) -
        //      правильным будет использование notifyAll();
        //   2) notify() целесообразно использовать, когда нет разницы, какому потоку
        //      передавать управление, когда мы не боимся "потерять" это оповещение
        //      и зависнуть, или когда у нас, например, всего 2 потока
        notifyAll();
    }

    public synchronized void nextTurn() {
        turn = (turn + 1) % maxTurn;
    }
 }
